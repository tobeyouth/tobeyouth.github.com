---
layout: post
title: "同源策略和跨域"
modified: 2016-09-14 11:29:54 +0800
tags: [web, ajax, iframe, canvas]
---


在前端开发的过程中，我们经常遇到"跨域"的问题，以下的文章将列举一下我在工作中碰到的跨域问题。
以及稍稍的探讨一下为什么会有"跨域"问题的出现，和所谓的"同源策略"

## 同源策略

### 历史

1995 年由 `Netscape` 公司提出，之后被其他浏览器厂商采纳。

同源策略只是一个规范，并没有指定其具体的使用范围和实现方式，各个浏览器厂商都针对同源策略做了自己的实现。

一些 web 技术都默认采取了同源策略，这些技术范围包括但不限于`Silverlight`, `Adobe  Flash`, `Adobe Acrobat`, `Dom`, `XMLHttpRequest`。

### 定义
> Under the policy, a web browser permits scripts contained in a first web page to access data in a second web page, but only if both web pages have the same origin. An origin is defined as a combination of *URI scheme*, *hostname*, and *port number*.

判断同源的三个要素：

- 相同的协议
- 相同的域名
- 相同的端口号

### 存在的意义

> 为了保证使用者信息的安全，防止恶意网站篡改用户数据

举个例子：

假设没有同源策略，那么我在A网站下的`cookie`就可以被任何一个网站拿到；那么这个网站的所有者，就可以使用我的`cookie`(也就是我的身份)在A网站下进行操作。

同源策略可以算是 web 前端安全的基石，如果缺少同源策略，浏览器也就没有了安全性可言。

### 限制范围

非同源的网站之间

- 无法共享 cookie, localStorage, indexDB
- 无法操作彼此的 dom 元素
- 无法发送 ajax 请求
- 无法通过 flash 发送 http 请求
- 其他


## 跨域

同源策略做了很严格的限制，但是在实际的场景中，又确实有很多地方需要**突破**同源策略的限制，也就是我们常说的`跨域`

### cookie

同源策略最早被提出的时候，为的就是防止不同域名的网页之间共享 cookie，但是如果两个网页的一级域名是相同的，可以通过设置 `document.domain`来共享 cookie。

举个例子，
`https://market.douban.com`和`https://book.douban.com`，这两个网页的一级域名都是 `douban.com`，如果我在 `market.douban.com`中执行了 

```
document.domain = 'douban.com'
document.cookie = 'cross=yes'

或

document.cookie = 'cross=yes;path=/;domain=douban.com'

```

这样设置了 cookie 之后，在 `book.douban.com` 中是可以取到这个 cookie 的。

除了在前端设置之外，也可以直接在 response 里将 cookie 的 domain 设置成 `.douban.com`。

### Ajax

在使用 ajax 的过程中，我们碰到的同源限制的问题是最多的。

针对 ajax ，我们有三种方式可以绕过同源策略的限制：

#### 设置 CORS

设置 cross-domain 是目前在 ajax 中最常用的一种跨域的方式，相比`jsonp`和`websoket`也是最安全的一种方式。

唯一美中不足的是低版本的浏览器支持的不是很好

> IE ✘ 5.5+ ◒ 8+² ◒ 10+¹ ✔ 11

> Edge ✔

> Firefox ✘ 2+ ✔ 3.5+

> Chrome ◒ 4+¹ ✔ 13+

> Safari ✘ 3.1+ ◒ 4+¹ ✔ 6+³

> Opera ✘ 9+ ✔ 12+
 
> ¹Does not support CORS for images in `<canvas>`
 
> ²Supported somewhat in IE8 and IE9 using the XDomainRequest object (but has [limitations](http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx))

>³Does not support CORS for `<video>` in `<canvas>`: https://bugs.webkit.org/show_bug.cgi?id=135379

#### CROS 的运作
CROS 的设置，大部分是需要在服务端进行设置，在服务端设置之前，先来看一下 CROS 在浏览器中是怎么运作的：

首先，在浏览器中，http 请求将被分为两种 `简单请求(simple request)` 和 `非简单请求(not-so-simple request)`。

简单请求的判断包括两个条件：

1. 请求方法必须是一下几种:
	- HEAD
	- GET
	- POST

2. HTTP 头只能包括以下信息：
	- Accept
	- Accept-Language
	- Content-Language
	- Last-Event-ID
	- Content-Type: 只限于[application/x-www-form-urlencoded, multipart/form-data, text/plain]

不能同时满足以上两个条件的，就都视作`非简单请求`

#### 简单请求

##### 浏览器端
浏览器在处理简单请求时，会在 Header 中加上一个 `origin(protocal + host + path + port)` 字段，来标明这个请求是来自哪里。

在 CROS 请求中，默认是不会携带 `cookie`之类的用户信息的，但是不携带用户信息的话，是没办法判断用户身份的，所以，可以在请求时将`withCredentials`设置为 true, 例如：

```
var xhr = new XMLHttpRequest()
xhr.withCredentials = true
```

设置了这个值之后，在服务端会将 `response` 中的 `Access-Control-Allow-Credentials` 也设置为 `true`，这样浏览器才会相应 `cookie`

##### 服务端

在服务端拿到这个请求之后，会对 origin 进行判断，如果是在允许范围内的请求，将会在 respones 返回的 Header 中加上：

```
Access-Control-Allow-Origin: origin
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: something
```

下面来说说这几个字段都代表什么：

- Access-Control-Allow-Origin: 看名字大概就能猜出来，这个就是告诉浏览器，服务端接受那些域名的访问。值可以是 `request` 中的 `origin`，也可以是 `*`，也可以是`originA | originB` 这样的形式，但是目前看来，在浏览器中只支持单一值和`*`两种方式。具体可以参考这里：[access-control-allow-origin-response-header](https://www.w3.org/TR/cors/#access-control-allow-origin-response-header)

- Access-Control-Allow-Credentials: 从名字上来看，这个字段标明了是否拥有用户相关的权限。

	在浏览器中，具体表现为是否可以发送 cookie。这个值可以选择性返回，如果不返回的话，默认就是不允许发送 cookie，如果返回，则只能返回 true。
	
	另外，如果这个值被设为了`true`，那么`Access-Control-Allow-Origin`就不能被设置为`*`，必须要显示指定为`origin`的值；并且返回的`cookie`因为是在被跨域访问的域名下，因为遵守同源策略，所以在`origin`网页中是不能被读取到的。

- Access-Control-Expose-Headers: 从字面意义上来看，这个字段返回的就是**其他**可被返回的数据。
	
	之所以会有这个字段，是因为在`简单请求`中，`response`返回的头信息中，浏览器只能拿到以下几个基本字段：`Cache-Control`, `Content-Language
`, `Content-Type`, `Expires`, `Last-Modified`, `Pragma`。

	如果想要拿到更多的额外信息，只能在`Access-Control-Expose-Headers`里设置，例如：

	```
 	Access-Control-Expose-Headers: "Foo=foo"
	```
	这样的话，在浏览中，就可以获取 `Foo` 这个字段所携带的信息了


#### 非简单请求

与`简单请求`最大的不同在于，`非简单请求`实际上是发送了两个请求。

#### 预请求

首先，在正式请求之前，会先发送一个`预请求(preflight-request)`，这个请求的作用是尽可能少的携带信息，供服务端判断是否响应该请求。

##### 浏览器

浏览器发送`预请求`，请求的 `Request Method` 会设置为 `options`。

另外，还会带上这几个字段：

- Origin: 同`简单请求`的`origin`
- Access-Control-Request-Method: 请求将要使用的方法
- Access-Control-Request-Headers: 浏览器会额外发送哪些头信息

##### 服务端

服务端收到`预请求`之后会根据`request`中的`origin`,`Access-Control-Request-Method`和`Access-Control-Request-Headers`判断是否响应该请求。

如果判断响应这个请求，返回的`response`中将会携带：

- Access-Control-Allow-Origin: origin
- Access-Control-Allow-Methods: like request
- Access-Control-Allow-Headers: like request

如果否定这个请求，直接返回不带这三个字段的`response`就可以，浏览器将会把这种返回判断为失败的返回，触发`onerror`方法


#### 正式响应

如果`预请求`被正确响应，接下来就会发送正式请求，正式请求的`request`和正常的 ajax 请求基本没有区别，只是会携带 `origin` 字段；`response`和`简单请求`一样，会携带上`Access-Control-*`这些字段

#### 使用 websocket


#### 使用 jsonp

### iframe

### canvas

### flash

###参考文章:
- [Same-origin policy](https://en.wikipedia.org/wiki/Same-origin_policy)
- [浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)
- [security-with-canvas-elements](https://html.spec.whatwg.org/multipage/scripting.html#security-with-canvas-elements)
- [concept-canvas-origin-clean](https://html.spec.whatwg.org/multipage/scripting.html#concept-canvas-origin-clean)

