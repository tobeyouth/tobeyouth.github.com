<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://tobeyouth.github.io/pages/tobeyouth/feed.xml" rel="self" type="application/atom+xml" /><link href="https://tobeyouth.github.io/pages/tobeyouth/" rel="alternate" type="text/html" /><updated>2021-02-20T05:14:20+00:00</updated><id>https://tobeyouth.github.io/pages/tobeyouth/feed.xml</id><title type="html">tobeyouth</title><subtitle>jekyll blog</subtitle><entry><title type="html">记录一些有用的(前端)库</title><link href="https://tobeyouth.github.io/pages/tobeyouth/blog/2020/06/11/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BA%93/" rel="alternate" type="text/html" title="记录一些有用的(前端)库" /><published>2020-06-11T00:00:00+00:00</published><updated>2020-06-11T00:00:00+00:00</updated><id>https://tobeyouth.github.io/pages/tobeyouth/blog/2020/06/11/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BA%93</id><content type="html" xml:base="https://tobeyouth.github.io/pages/tobeyouth/blog/2020/06/11/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BA%93/">&lt;p&gt;持续记录一些有用的库，主要是在前端的工作范畴内，会包含日常开发和工程化等几个大类，使用过的会附上一些使用感受，大概就这样吧。&lt;/p&gt;

&lt;h1 id=&quot;业务相关&quot;&gt;业务相关&lt;/h1&gt;

&lt;h3 id=&quot;react-virtualized&quot;&gt;react-virtualized&lt;/h3&gt;

&lt;p&gt;移动端web页面对比native最绕不过去的一个坎儿就是：性能；尤其是在长列表上的表现。iOS
天然带有长列表优化，当界面中的列表内容变得，且列表元素较为复杂时，移动端 web 页面的性能劣势会体现的更加明显。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;react-virtualized&lt;/code&gt;可以算作当前 react 生态中，优化长列表最常使用的组件，其原理就是只渲染可见区域内的元素，滚动高度等通过
css 方法来模拟。并且提供了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;InfiniteLoader /&amp;gt;&lt;/code&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;AutoSizer
/&amp;gt;&lt;/code&gt;等直接解决滚动加载和高度计算的组件，让优化过的长列表的使用方式更贴近普通列表的使用方式。&lt;/p&gt;

&lt;p&gt;虽然已经做了很多的优化，但是就目前的体验来说，如果列表过长，或者列表元素较为复杂时，还是会出现不流畅以及白屏的情况。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实用程度: ★★★★&lt;/li&gt;
  &lt;li&gt;易用性: ★★★★&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bvaughn.github.io/react-virtualized/&quot;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/bvaughn/react-virtualized&quot;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;react-keep-alive&quot;&gt;react-keep-alive&lt;/h3&gt;

&lt;p&gt;在开发一些 &lt;em&gt;List -&amp;gt; Detail&lt;/em&gt; 页面时，如果 List 很长的话，通常会希望从 List 进入到 Detail，再返回后，List
仍然可以保持之前的状态；如果在单纯的 spa 环境下是无法实现的，因为从 List 进入到 Detail 时，List 已经被 unmount
掉了，再次进入只能是重新渲染。&lt;/p&gt;

&lt;p&gt;这个库就是为了解决这个问题而产生的，可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;KeepAlive /&amp;gt;&lt;/code&gt; 的组合来在本地缓存住对应的页面。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实用程度: ★★★★&lt;/li&gt;
  &lt;li&gt;易用性: ★★★★&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/StructureBuilder/react-keep-alive&quot;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;工程化&quot;&gt;工程化&lt;/h1&gt;

&lt;h3 id=&quot;webpack-merge&quot;&gt;webpack-merge&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;webpack&lt;/code&gt; 已经是现代前端开发的标配了，在项目中, production、development、dev 环境中的 webpack config
通常都会有一些细微的差别，虽然 webpack config 中已经提供了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mode&lt;/code&gt; 参数可以快速配置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;development&lt;/code&gt;
和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;production&lt;/code&gt;，但在较为大型的项目上，还是不能够满足需求。&lt;/p&gt;

&lt;p&gt;通常我的做法是会提取一份公用的 webpack config，以此作为 base config，然后通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;webpace config&lt;/code&gt; 来直接把 base config 和
env config 再 merge 成一份，然后使用，避免了写很多重复的配置项的工作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实用程度: ★★★★★&lt;/li&gt;
  &lt;li&gt;易用性: ★★★★ (不建议使用 smart merge)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/survivejs/webpack-merge&quot;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;工作方式&quot;&gt;工作方式&lt;/h1&gt;

&lt;h3 id=&quot;commitizen&quot;&gt;commitizen&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commitizen&lt;/code&gt; 是一个可以将 git commit
快速格式化的工具，提供了一个固定的句式，只需要按照提示填入所需的内容，即可生成整齐的 git commit log。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实用程度: ★★★★★&lt;/li&gt;
  &lt;li&gt;易用性: ★★★★★&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://commitizen.github.io/cz-cli/&quot;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/commitizen/cz-cli&quot;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="blog" /><category term="javascrip" /><category term="webpack" /><category term="react" /><category term="typescript" /><summary type="html">持续记录一些有用的库，主要是在前端的工作范畴内，会包含日常开发和工程化等几个大类，使用过的会附上一些使用感受，大概就这样吧。</summary></entry><entry><title type="html">redux, redux-saga and socket.io</title><link href="https://tobeyouth.github.io/pages/tobeyouth/blog/2018/09/21/redux&redux-saga&socket.io/" rel="alternate" type="text/html" title="redux, redux-saga and socket.io" /><published>2018-09-21T00:00:00+00:00</published><updated>2018-09-21T00:00:00+00:00</updated><id>https://tobeyouth.github.io/pages/tobeyouth/blog/2018/09/21/redux&amp;redux-saga&amp;socket.io</id><content type="html" xml:base="https://tobeyouth.github.io/pages/tobeyouth/blog/2018/09/21/redux&amp;redux-saga&amp;socket.io/">&lt;p&gt;最近公司举行 hackthon, 做了个棋牌类的游戏, 前端的主要技术栈就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;react&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket.io&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;react&lt;/code&gt; 没什么可说的了，基本已经是前端标配了。本来 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 作为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;react&lt;/code&gt; 全家桶的一部分，也没什么可讨论的了。&lt;/p&gt;

&lt;p&gt;但是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt;作为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 的神奇 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middleware&lt;/code&gt;, 如果不熟悉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 的话, 很难真正理解 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt;, 所以顺路再梳理一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 的使用方法和哲学。&lt;/p&gt;

&lt;h2 id=&quot;redux&quot;&gt;redux&lt;/h2&gt;

&lt;p&gt;上来先是一个官方文档&lt;a href=&quot;https://redux.js.org/&quot;&gt;redux&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 到底是什么呢？&lt;/p&gt;

&lt;p&gt;先来看官方的一句话简介：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Redux is a predictable state container for JavaScript apps.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单明了的说呢, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 就是一个管理 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt; 的东西。&lt;/p&gt;

&lt;p&gt;那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt; 又是什么呢？&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt; 我们可以理解为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;状态&lt;/code&gt;, 那 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 是个状态机吗？&lt;/p&gt;

&lt;p&gt;答案是, &lt;strong&gt;可以这么理解&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;除了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt;,简介里还提到了一个至关重要的词 - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;predictable&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;那么什么才算是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;predictable&lt;/code&gt; 呢？&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 的实现里, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;predictable&lt;/code&gt; 被实现成了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;functional&lt;/code&gt;,  也就是俗称的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;函数式&lt;/code&gt;。函数式编程这里就不多说了, 有兴趣的可以上网搜一搜, 相关的介绍很多。&lt;/p&gt;

&lt;p&gt;那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 又是如何做到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;predictable&lt;/code&gt; 的呢？简单来说, 就是把所有可能更新 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt; 的操作都放到了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducer&lt;/code&gt; 中, 通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 来驱动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducer&lt;/code&gt; 做出不同的操作。并且 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducer&lt;/code&gt; 都是纯函数, 从而达到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;predictable&lt;/code&gt;目的。&lt;/p&gt;

&lt;h4 id=&quot;three-principles&quot;&gt;three principles&lt;/h4&gt;

&lt;p&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 只需记住这三条原则, 就基本上可以使你的 app 达到一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;predictable&lt;/code&gt; 的状态。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;single source of truth&lt;/p&gt;

    &lt;p&gt;一部分业务, 只维护一个数据源(也可以理解为,只是用一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt;)。&lt;/p&gt;

    &lt;p&gt;但并不是整个应用都要使用一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt;, 而是同一部分业务, 只使用一个数据源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;state is read-only&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;永远不要尝试直接修改你的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt;, 如果要修改 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt;, 请触发 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt;, 让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducer&lt;/code&gt; 去修改.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;changes are made with pure functions&lt;/p&gt;

    &lt;p&gt;只使用&lt;strong&gt;纯函数&lt;/strong&gt;来更新 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt;。&lt;/p&gt;

    &lt;p&gt;为什么要使用纯函数？&lt;/p&gt;

    &lt;p&gt;因为纯函数是完全可预测的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;flow--api&quot;&gt;flow &amp;amp; api&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 本身是个很简单的库, 最可贵的是提出了上面的三条原则, 并且在代码层面提供了执行这三条原则的结构和 api。&lt;/p&gt;

&lt;p&gt;整个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt;的执行流程, 可以用伪代码的形式来表达一下&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;creatStore --&amp;gt;
user interface ---&amp;gt; 
store.dispatch(action&amp;lt;Function&amp;gt;) --&amp;gt; 
reducer&amp;lt;Function&amp;gt; to change the state and return new state --&amp;gt;
rerender view
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来再看下在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 中, 是如何通过几个 api 来实现这个过程的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;createStore(reducer, preloadedState, enhancer)&lt;/p&gt;

    &lt;p&gt;源码&lt;a href=&quot;https://github.com/reduxjs/redux/blob/master/src/createStore.js&quot;&gt;在此&lt;/a&gt;，减去注释, 大概也就 100 多行代码。&lt;/p&gt;

    &lt;p&gt;顾名思义, 就是创建了个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store&lt;/code&gt;, 通过看源码, 我们可以知道这个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store&lt;/code&gt; 有以下几个方法：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;dispatch&lt;/li&gt;
      &lt;li&gt;subscribe&lt;/li&gt;
      &lt;li&gt;getState&lt;/li&gt;
      &lt;li&gt;replaceReducer&lt;/li&gt;
      &lt;li&gt;[$$observable]&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;combineReducers(reudcers)&lt;/p&gt;

    &lt;p&gt;在真实的开发环境中, 通常我们开发一个完整的应用, 在一些复杂的页面中, 不可能仅仅使用一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt; 就能完整的表达整个应用的状态, 这时多个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt; 可能面对的就是多个不同的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducer&lt;/code&gt;, 但是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;createStore&lt;/code&gt; 这个 api 只能接收一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducer&lt;/code&gt;, 要怎么办呢？&lt;/p&gt;

    &lt;p&gt;这个时候, 我们就需要用到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;combineReducers&lt;/code&gt;了, 它返回一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;combination&lt;/code&gt; 方法, 在这个方法中, 会将传入的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducers&lt;/code&gt; 逐个执行, 返回的是根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducer&lt;/code&gt; 的 name, 处理后的不同的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;bindActionCreators(actionCreators, dispatch):&lt;/p&gt;

    &lt;p&gt;通常一个应用中, 会触发很多 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt;, 这些 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 触发函数的集合, 就叫做 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;actionCreators&lt;/code&gt;。&lt;/p&gt;

    &lt;p&gt;另外, 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;createStore&lt;/code&gt; 中, 我们返回的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store&lt;/code&gt; 是带有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 方法的, 这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 方法就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindActionCreators&lt;/code&gt;的第二个参数。&lt;/p&gt;

    &lt;p&gt;这个 api 的主要作用就是连接了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store.dispatch&lt;/code&gt; 和定义的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;actionCreators&lt;/code&gt;, 使触发的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 可以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;container&lt;/code&gt; 中执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;compose(…funcs)&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compose&lt;/code&gt; 返回一个高阶函数, 可以将 functions 从左到右按 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce&lt;/code&gt; 的方式执行&lt;/p&gt;

    &lt;p&gt;代码非常简单, 看这里:&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export default function compose(...funcs) {
  if (funcs.length === 0) {
    return arg =&amp;gt; arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }

  return funcs.reduce((a, b) =&amp;gt; (...args) =&amp;gt; a(b(...args)))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;applyMiddleware(…middlewares)&lt;/p&gt;

    &lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 的执行流程中, 可能会有一些多个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducer&lt;/code&gt; 通用的操作, 这个操作, 可以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 的 flow 中, 执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducer&lt;/code&gt; 前执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middleware&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middleware&lt;/code&gt; 将以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce&lt;/code&gt;的方式逐个执行, 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middleware&lt;/code&gt; 中可以获取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispath&lt;/code&gt; 其他的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;actionCreator&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过这几个 api, 即可实现上面所描述的三条原则, 具体怎么实现, 我们将以接下来的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;react-redux&lt;/code&gt; 为例, 展开说说。&lt;/p&gt;

&lt;h2 id=&quot;react-redux&quot;&gt;react-redux&lt;/h2&gt;

&lt;p&gt;之所以把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;react-redux&lt;/code&gt; 放上来, 主要是为了看下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 的几个 api 在真实的开发环境中, 是如何使用的。&lt;/p&gt;

&lt;p&gt;还是先来看看 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;react-redux&lt;/code&gt; 的 api 吧：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Provider&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Provider&lt;/code&gt;实际上是一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React Component&lt;/code&gt;, 它接收一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;props&lt;/code&gt;, 就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;createStore&lt;/code&gt; 这个方法返回的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;createProvider&lt;/li&gt;
  &lt;li&gt;connectAdvanced&lt;/li&gt;
  &lt;li&gt;connect&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;redux-saga&quot;&gt;redux-saga&lt;/h2&gt;

&lt;h2 id=&quot;socketio&quot;&gt;socket.io&lt;/h2&gt;

&lt;h2 id=&quot;mix-them-all&quot;&gt;mix them all&lt;/h2&gt;</content><author><name></name></author><category term="blog" /><category term="redux" /><category term="redux-saga" /><category term="socket.io" /><summary type="html">最近公司举行 hackthon, 做了个棋牌类的游戏, 前端的主要技术栈就是 react + redux + redux-saga + socket.io</summary></entry><entry><title type="html">start-at-bitcoin</title><link href="https://tobeyouth.github.io/pages/tobeyouth/blog/2018/08/22/start-at-bitcoin/" rel="alternate" type="text/html" title="start-at-bitcoin" /><published>2018-08-22T00:00:00+00:00</published><updated>2018-08-22T00:00:00+00:00</updated><id>https://tobeyouth.github.io/pages/tobeyouth/blog/2018/08/22/start-at-bitcoin</id><content type="html" xml:base="https://tobeyouth.github.io/pages/tobeyouth/blog/2018/08/22/start-at-bitcoin/">&lt;h3 id=&quot;诞生&quot;&gt;诞生&lt;/h3&gt;

&lt;p&gt;比特币诞生于 2008 年，一个网名为&lt;strong&gt;中本聪&lt;/strong&gt;的人，提出了一个设想：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;创造一种不受政府或任何组织控制的货币&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比特币的本质就是一串数字，没有任何资产支持（现行货币背后都是国家或银行提供资产支持）。也就是说，比特币是一个完全出于&lt;strong&gt;社区共识&lt;/strong&gt;的货币。&lt;/p&gt;

&lt;h3 id=&quot;货币是什么&quot;&gt;货币是什么&lt;/h3&gt;

&lt;p&gt;wikipedia 上对货币的定义为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;货币，称钱财，是人们为提高交易效益，对一种媒介达成的共识。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们现在正在使用的纸币，其实可以看成是&lt;strong&gt;共识&lt;/strong&gt;的实体代表。如果没有纸币，货币仍然是成立的，比如银行账户里的钱。&lt;/p&gt;

&lt;p&gt;基于这个定义，任何一个事物，不管是实体的还是虚拟的，只要在大家的共识中，它是有价值的，那么就可以当做货币来使用，比特币正是这样一种事物。&lt;/p&gt;

&lt;p&gt;而且相较于银行账户里的货币，比特币的数据全部存放在区块链上，更不容易被破坏。&lt;/p&gt;

&lt;h3 id=&quot;比特币的运行&quot;&gt;比特币的运行&lt;/h3&gt;

&lt;p&gt;货币的运行主要是通过交易，也就是货币从 A 到 B 这样一个过程。比特币也不例外，不过比特币的交易并不是手递手的传递，而是通过从 A 的比特币地址到 B 的比特币地址来完成的。&lt;/p&gt;

&lt;p&gt;对于比特币来说，并不存在&lt;strong&gt;人&lt;/strong&gt;这个概念，比特币都是从&lt;strong&gt;地址&lt;/strong&gt;到&lt;strong&gt;地址&lt;/strong&gt;的。另外，我们上面说过，比特币的所有数据都是存在区块链上的，所有数据都是公开的，所以想要查到某个地址有多少比特币，是非常容易的。&lt;/p&gt;

&lt;p&gt;看起来好像是所有的信息都被暴露了，但是有一点非常关键的是，没有人知道地址背后的人到底是谁，这为比特币提供了非常好的匿名性。&lt;/p&gt;

&lt;h4 id=&quot;公钥私钥&quot;&gt;公钥/私钥&lt;/h4&gt;

&lt;p&gt;上面一直在强调&lt;strong&gt;地址&lt;/strong&gt;这个东西，比特币地址的基础是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;非对称加密算法&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;那么什么又是非对称加密算法呢？&lt;/p&gt;

&lt;p&gt;举个简单的例子，在谍战剧中，我们常看到有特工截获敌人的电报信号，但是出于安全性考虑，这些电报的内容其实都是加密过的。通常情况下是有个密码本，发送方和接收方各执一份，这就叫做&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;对称加密&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;内容先加密再发送，接收方收到消息后，先解密再阅读。&lt;/p&gt;

&lt;p&gt;但是这样的方式有个严重的缺点，就是加密规则（密码本）一旦泄露或者被破译，那么发送的内容就跟不加密没有区别了。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，1970年，有两个美国科学家提出了一种被称作&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Diffie–Hellman key exchange&lt;/code&gt;的算法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://image.ibb.co/b4GKXe/Diffie_Hellman.png&quot; alt=&quot;Diffie–Hellman&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使加密和解密可以使用不同的规则，从而也就避免了密码本失窃之后导致的安全问题，这种加密方式，就被称为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;非对称加密&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在非对称加密中，基本就是执行了这样几个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A 生成了两把密钥（公钥/私钥），A 把公钥发送给 B&lt;/li&gt;
  &lt;li&gt;B 获得了 A 的公钥，同时用公钥对信息进行加密，并把加密后的信息发送给 A&lt;/li&gt;
  &lt;li&gt;A 收到了加密后的信息，然后用私钥解密，获得真正的内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在这个过程中，如果 A 的私钥不被泄露的话，那么用 A 的公钥加密的信息，只有 A 才能够解开，从而保证了安全性。&lt;/p&gt;

&lt;h4 id=&quot;比特币钱包地址&quot;&gt;比特币钱包/地址&lt;/h4&gt;

&lt;p&gt;说了半天加密，那么加密是为了什么呢？答案就是为了钱包/地址。&lt;/p&gt;

&lt;p&gt;比特币钱包其实就是一个存储公钥/私钥的地方。&lt;/p&gt;

&lt;p&gt;通常，会生成一个 256 位的私钥；和一个 512 位的公钥（与其他加密系统不同的是，比特币钱包中的公钥，直到第一次交易时，才会被公开）。&lt;/p&gt;

&lt;p&gt;因为 512 位的公钥实在是太长了，所以会再生成一个比特币钱包的地址，用来做交易。首先会通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SHA-256&lt;/code&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RIPEMD&lt;/code&gt; 算法将公钥变成一个 160 位的 hash 值，这个 hash 值也被称为指纹；但是 160 位还是太长，接下来会通过一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Base58Check&lt;/code&gt; 的方法，将这个 160 位的 hash 编码成一个长度为 26 ~ 35 的 base58 字符串，这个字符串就是比特币钱包的地址。&lt;/p&gt;

&lt;p&gt;接着，会根据私钥，再通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Base58Check&lt;/code&gt;方法，生成一个较短的 base58 格式的字符串，这个字符串被称作 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Wallet Interchange Format(WIF)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;到最后，我们一共得到了三种不同的 key，分别是&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;两个密钥
    &lt;ul&gt;
      &lt;li&gt;256 位的私钥&lt;/li&gt;
      &lt;li&gt;512 位的公钥&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;一个 160 位的公钥的 hash&lt;/li&gt;
  &lt;li&gt;较短的 base58 格式的两个字符串
    &lt;ul&gt;
      &lt;li&gt;钱包地址&lt;/li&gt;
      &lt;li&gt;钱包交换格式(WIF)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;流程和关系可以看下面这个图，会更清晰一些：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.righto.com/images/bitcoin/bitcoinkeys.png&quot; alt=&quot;bitcoin keys&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;交易&quot;&gt;交易&lt;/h4&gt;

&lt;p&gt;比特币的交易流程整体看起来非常简单，一共分为以下几个步骤&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A 向 B 发起转账&lt;/li&gt;
  &lt;li&gt;根据比特币协议, 验证这笔交易是否可行&lt;/li&gt;
  &lt;li&gt;如果可行, 由矿工将交易信息打包, 写到区块链上&lt;/li&gt;
  &lt;li&gt;写入成功, 即代表交易成功&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是跟通常情况下，银行账号间的转账交易不同，比特币的交易本身不存在&lt;strong&gt;账户&lt;/strong&gt;这样一个概念，A 向 B 转账，比特币并不真正落入 B 的某个账户中，而只是标记了 B &lt;strong&gt;拥有将这部分比特币转出的权利&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;下面这个图记录了 3 个比特币交易的数据：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.righto.com/images/bitcoin/transaction_diagram-s800.png&quot; alt=&quot;transactions&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Transaction A&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Transaction B&lt;/code&gt; 分别转了 0.005btc 和 0.003btc 到了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Transaction C&lt;/code&gt;, 之后 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Transaction C&lt;/code&gt; 又分别转出了 0.003btc 和 0.004btc。剩下的 0.001 btc，就作为矿工的费用，归矿工所有了。&lt;/p&gt;

&lt;p&gt;在比特币交易的过程中，因为记录的是交易本身，所以有一个原则就是每笔交易的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;input&lt;/code&gt; 总和 一定要等于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output&lt;/code&gt;总和。&lt;/p&gt;

&lt;p&gt;假设一笔交易收到了 100btc，但是真正想转出去的只有 1btc，但是根据上面的原则，这笔交易的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output&lt;/code&gt; 总和一定要是 100btc，解决办法就是将剩下的 99btc 再做一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output&lt;/code&gt; 转回到自己的钱包地址。&lt;/p&gt;

&lt;p&gt;我们随便找个比特币&lt;a href=&quot;https://www.blockchain.com/zh-cn/btc/tx/c18e5cdb816262d2ebc47c35c77bdb32a6324f4ac507dff310159aa448054a62&quot;&gt;交易记录&lt;/a&gt;看下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://image.ibb.co/eNhMf9/image.png&quot; alt=&quot;看这里&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入和输入是一致的。&lt;/p&gt;

&lt;h4 id=&quot;找零&quot;&gt;找零&lt;/h4&gt;
&lt;p&gt;###
交易过程中，会存在&lt;strong&gt;找零&lt;/strong&gt;的问题，比如上面我们讲到：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;假设一笔交易收到了 100btc，但是真正想转出去的只有 1btc，但是根据上面的原则，这笔交易的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output&lt;/code&gt; 总和一定要是 100btc，解决办法就是将剩下的 99btc 再做一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output&lt;/code&gt; 转回到自己的钱包地址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个动作就称为找零。&lt;/p&gt;

&lt;p&gt;在真实的比特币世界中，通常情况下，找零是会返回到一个新的地址上，而不是原地址。这么做的主要原因有两个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先，如果一笔交易存在找零，那么在查看交易记录时，并不会标记出哪个是目标地址，哪个是找零地址，所以也就是说难以猜到交易的真正对象。&lt;/li&gt;
  &lt;li&gt;其次，因为在交易过程中，转出方公布了自己的公钥，虽然以现在的计算机的算力很难通过公钥反推出私钥，但是并不代表未来也不能反推。所以每次找零都返回到一个新的地址，相当于把剩下的资产做了转移，从而隐藏了公钥。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;utxo&quot;&gt;UTXO&lt;/h4&gt;

&lt;p&gt;所谓 UTXO 全称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unspent Transaction Output&lt;/code&gt;，它是比特币交易的基本单位。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;UTXO 是不能再分割、被所有者锁住的或记录与区块链中的并被整个网络识别成或单位的一定量的比特币。(&lt;a href=&quot;https://bitcoin.stackexchange.com/questions/64504/what-does-unable-to-decode-output-address-mean&quot;&gt;原文见这里&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比较通俗的讲，一次交易中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output&lt;/code&gt;，其实就是一个 UTXO，假设我手里有一张 10 块钱，一张 5 块钱，但是我想买一个 12 块钱的东西；那么我一次性要 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output&lt;/code&gt; 两个人民币，分别是 10 块和 5 块，然后又找回给我 3 块钱，那么这个 3 块钱，也是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTXO&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;交易过程中的验证&quot;&gt;交易过程中的验证&lt;/h4&gt;

&lt;p&gt;因为是完全去中心且匿名的交易，所以在交易的过程中，会需要一些验证，来证明该交易是否是符合规则的。&lt;/p&gt;

&lt;p&gt;每一次的交易，都会要求转出方提供以下信息，以验证当前的交易是否合法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上一笔交易的 hash&lt;/li&gt;
  &lt;li&gt;转出方的公钥&lt;/li&gt;
  &lt;li&gt;转出方私钥生成的数字签名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了验证交易是否可以正常进行，需要以下三个步骤&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;找到上一笔交易，以确认支付方确实有能力支付本次交易&lt;/li&gt;
  &lt;li&gt;算出支付方公钥的指纹，确保与支付方地址一致&lt;/li&gt;
  &lt;li&gt;使用公钥解开数字签名，以验证私钥属实&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体的步骤，可以参加这个图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.righto.com/images/bitcoin/bitcoin_transaction_chain-s512.png&quot; alt=&quot;bitcoin_transaction_chain&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经过验证之后，当前的交易将会被矿工打包，并写到区块链中。具体的写入过程可以参考&lt;a href=&quot;https://tobeyouth.github.io/blog/2018/08/21/start-at-blockchain/&quot;&gt;这篇文章&lt;/a&gt;中的介绍。根据比特币的协议，一个区块的大小是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1MB&lt;/code&gt;, 而一笔交易大概是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;500b&lt;/code&gt;，因此一个区块大概可以包含 2000 笔交易。矿工负责将这些交易打包，算出 hash，再写入到链上。&lt;/p&gt;

&lt;p&gt;因为打包写入到区块链上，是一个会消耗大量计算的过程，所以矿工的工作并不是义务劳动。根据比特币的协议规定，成功添加新区块的矿工将获得奖励，一开始是 50btc，然后每 4 年减半；另一方面，因为比特币最多只支持到小数点后面 8 位，所以可以得出到了 2140 年，矿工将得不到任何奖励。到时候，矿工所能获得到的收益就只能是交易手续费了。&lt;/p&gt;

&lt;p&gt;所谓的交易手续费，是由交易方付给矿工的，具体的金额随意。但是矿工会优先选择手续费较高的交易进行打包，以预期获得更高的收益。所以也就是付给矿工的手续费越高，那么交易也就会被越早确认。&lt;/p&gt;

&lt;h4 id=&quot;交易中产生的冲突&quot;&gt;交易中产生的冲突&lt;/h4&gt;

&lt;p&gt;因为是非同步的，而且节点间的同步有可能会出现延迟。所以，就有可能存在同一笔交易被写到了两个区块中的情况，为了解决这种情况所造成的冲突。&lt;/p&gt;

&lt;p&gt;比特币的链上规则中做了规定，因为区块是前后链接的，所以一旦出现分叉，那么哪个区块后面跟着的区块多，就判定哪个分叉上的链是正确的，另一条链将被抛弃，其中打包的交易也将因为没有被写入到主链上而判定为失败。&lt;/p&gt;

&lt;h4 id=&quot;交易和账户&quot;&gt;交易和账户&lt;/h4&gt;

&lt;p&gt;上面说了半天，其实一直在说的都是交易。但是在主流的支付体系中，都是有&lt;strong&gt;账户&lt;/strong&gt;这一概念的，也就说，你收入多少，支出多少，构成了你账户中余额的多少。&lt;/p&gt;

&lt;p&gt;但是在比特币中，并不存在&lt;strong&gt;账户&lt;/strong&gt;这一概念，区块链上记录的就是交易，如果想知道一个地址上一共有多少比特币，那么需要遍历所有的交易，才能计算得出。&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/01/bitcoin-tutorial.html&quot;&gt;比特币入门教程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&quot;&gt;RSA算法原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&quot;&gt;Diffie–Hellman key exchange&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B&quot;&gt;菲迪-赫尔曼密钥交换算法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/RIPEMD&quot;&gt;RIPEMD&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Base58&quot;&gt;Base58&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bitcoin.org/en/bitcoin-paper&quot;&gt;bitcoin-paper&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;Protocol_documentation&quot;&gt;Protocol_documentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.michaelnielsen.org/ddi/how-the-bitcoin-protocol-actually-works/&quot;&gt;how-the-bitcoin-protocol-actually-works&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.blockchain.com/zh-cn/explorer&quot;&gt;比特币交易查询&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="blog" /><category term="bitcoin" /><summary type="html">诞生</summary></entry><entry><title type="html">start at blockchain</title><link href="https://tobeyouth.github.io/pages/tobeyouth/blog/2018/08/21/start-at-blockchain/" rel="alternate" type="text/html" title="start at blockchain" /><published>2018-08-21T00:00:00+00:00</published><updated>2018-08-21T00:00:00+00:00</updated><id>https://tobeyouth.github.io/pages/tobeyouth/blog/2018/08/21/start-at-blockchain</id><content type="html" xml:base="https://tobeyouth.github.io/pages/tobeyouth/blog/2018/08/21/start-at-blockchain/">&lt;p&gt;最近了解了一些区块链的东西，动了一些深入了解的心思。&lt;/p&gt;

&lt;p&gt;了解的过程中会不断补充和完善这篇文章，理解的不一定对，随意看看得了，每篇文章都会把阅读过的资料列出来，也方便大家去源头看看。&lt;/p&gt;

&lt;h3 id=&quot;区块链blockchain&quot;&gt;区块链（blockchain）&lt;/h3&gt;

&lt;p&gt;区块链是什么？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一句话，它是一种特殊的分布式数据库&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这句定义中有两个关键词&lt;strong&gt;分布式&lt;/strong&gt;和&lt;strong&gt;数据库&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;首先，我们可以把区块链看成是数据库，但是这个数据库并没有管理员，也没有中心，每个应用链的人，都具有平等的权利。&lt;/p&gt;

&lt;h3 id=&quot;区块&quot;&gt;区块&lt;/h3&gt;

&lt;p&gt;区块链是由一个个的&lt;strong&gt;区块(block)&lt;/strong&gt;组成的, 每个区块可以看做是一个存储数据的单元，每写入一次数据，就会新建一个区块，一个一个区块连接起来，就成了链状。&lt;/p&gt;

&lt;p&gt;每个区块分成两个部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;区块头(Block Head)&lt;/p&gt;

    &lt;p&gt;包含了当前区块的基本信息，包括 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成时间&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;区块体的 hash 值&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;上一个区块的 hash&lt;/code&gt; 等信息。&lt;/p&gt;

    &lt;p&gt;区块的 hash 就是根据区块头的内容来生成的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;区块体(Block Body)&lt;/p&gt;

    &lt;p&gt;区块体就是所含数据的真实内容&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;hash&quot;&gt;hash&lt;/h4&gt;

&lt;p&gt;区块的根本是源于 hash, 如果把区块链想象成一个真实的链状结构的话，那么 hash 就是每个元素之间的连接点。&lt;/p&gt;

&lt;h5 id=&quot;hash-的特征&quot;&gt;hash 的特征&lt;/h5&gt;

&lt;p&gt;关于 hash 的详尽定义，可以在 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8&quot;&gt;wikipedia&lt;/a&gt;中查看，这里简单总结一下 hash 的特征：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果两个 hash 是不相同的（根据同一函数），那么这两个 hash 的原始输入也是不相同的&lt;/li&gt;
  &lt;li&gt;hash 的输入和输出不是唯一对应关系的，如果两个 hash 值相同，两个输入值很可能是相同的，但也可能不同，这是由具体的 hash 计算方法决定的&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;hash-在区块链中的应用&quot;&gt;hash 在区块链中的应用&lt;/h5&gt;

&lt;p&gt;区块的内容与 hash 是一一对应的，每个区块的 hash 值都是不同的。同时，每一个区块又都保存着上一个区块的 hash 值。&lt;/p&gt;

&lt;p&gt;按照这个逻辑，如果一个区块的 hash 值变了的话，那么它之后的每一个区块的 hash 值都需要进行更新。&lt;/p&gt;

&lt;p&gt;进而延伸一下，如果有人想更新某一区块上的内容，那么他必须有能力依次更新这个区块后面所有区块的 hash 值才行，否则的话，被更新的区块就会脱离整个链了。由于更新区块 hash 的计算很复杂且耗时，所以除非掌握了全网 50% 以上的运算能力，否则更新某一区块的行为根本不可能成功。&lt;/p&gt;

&lt;p&gt;正是通过这种环环相扣的机制，区块链才可以保证自身数据的不可修改的特性。&lt;/p&gt;

&lt;h3 id=&quot;区块链是如何运行的&quot;&gt;区块链是如何运行的&lt;/h3&gt;

&lt;h4 id=&quot;挖矿&quot;&gt;挖矿&lt;/h4&gt;

&lt;p&gt;由于区块链是一条单一的链，每个区块都依赖于上一个区块，所以同一时间，只能向链上添加一个区块。&lt;/p&gt;

&lt;p&gt;又由于必须保证各个节点间的同步，所以添加完一个区块，各个节点又必须进行同步。&lt;/p&gt;

&lt;p&gt;也就是说，假设节点 A 正忙着生成新的区块，突然收到消息:“B 已经在链上添加了一个区块！”。这个时候 A 之前做的计算就都白做了，又得基于 B  新添加的节点，重新刚才的计算。并且计算的过程中，还会有类似的事情发生。&lt;/p&gt;

&lt;p&gt;上面我们说过，在区块链的运行机制中，通过区块自身的 hash 来判断当前区块是否可以被加入到链上。&lt;/p&gt;

&lt;p&gt;同时，为了使区块的添加速率趋于平均（比特币的设计是大约10分钟生成一个新的区块），并不是随便一个新建的区块都可以被添加到链上。&lt;/p&gt;

&lt;p&gt;通常会设置一个准入条件，只有符合该条件的区块，才可以被添加到链上，设计者通过设置海量的计算，来使计算满足加入条件的区块 hash 值变得非常困难，这个过程就叫做挖矿，也叫（mining）, 继续挖矿计算的机器, 我们就叫做矿机, 操作机器的人(其实是程序), 我们就叫做矿工。&lt;/p&gt;

&lt;h4 id=&quot;用-js-代码运行一下简单的挖矿机制&quot;&gt;用 js 代码运行一下简单的挖矿机制&lt;/h4&gt;

&lt;p&gt;首先，每一个区块，我们可以看成是由这几部分组成：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*Y3c_hIqCuiDH4x-8dObVyg.png&quot; alt=&quot;看这里&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是我们这个链上的第一个区块，这个区块包括了这样几个信息&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;index: 区块的 index 值, 这里应该是 0&lt;/li&gt;
  &lt;li&gt;previous hash: 前一个区块的 hash&lt;/li&gt;
  &lt;li&gt;timestamp: 区块创建时的时间戳&lt;/li&gt;
  &lt;li&gt;data: 区块包含的数据内容&lt;/li&gt;
  &lt;li&gt;hash: 区块本身的 hash&lt;/li&gt;
  &lt;li&gt;nonce: 计算区块 hash 的难度系数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们先假定这个区块的名字是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;, 接下来,我们在它后面再添加个区块 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;那么我的这个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 将包含以下这些信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;index: 1&lt;/li&gt;
  &lt;li&gt;previous hash: 也就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 的 hash&lt;/li&gt;
  &lt;li&gt;timestamp&lt;/li&gt;
  &lt;li&gt;data: I love Blockchain&lt;/li&gt;
  &lt;li&gt;hash: ?&lt;/li&gt;
  &lt;li&gt;nonce: ?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果要将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 添加到链上，那么我们接下来的工作就是计算出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce&lt;/code&gt; 的值，&lt;/p&gt;

&lt;p&gt;那么就假设我们计算 hash 的算法是这样的：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CryptoJS.SHA256(index + previousHash + timestamp + data + nonce)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来我们来计算这个 hash 值是否是一个准入的 hash, 代码如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function isValidHashDifficulty(hash, difficulty) {
  for (var i = 0, b = hash.length; i &amp;lt; b; i ++) {
      if (hash[i] !== '0') {
          break;
      }
  }
  return i &amp;gt;= difficulty;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们这里的准入条件为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash&lt;/code&gt; 中连续不为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 的值必须不小于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;difficulty&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;参数中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;difficulty&lt;/code&gt;, 也可以称为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;难度系数&lt;/code&gt;, 通过这个系数的动态调整，可以维持新增区块的平均速率。&lt;/p&gt;

&lt;p&gt;另外，我们上面计算 hash 的算法中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;index&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;previousHash&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timestamp&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 都是固定的，所以重复计算出来的 hash 值也应该是一样的，为了使每次计算出的 hash 不同, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce&lt;/code&gt;被设计成了一个变化的值, 通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce&lt;/code&gt;值的变化, 计算出不同的 hash, 从而判断  hash 值是否符合准入条件, 用代码表示的话. 就是这样：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let nonce = 0;
let hash;
let input;
while(!isValidHashDifficulty(hash, difficulty)) {     
  nonce = nonce + 1;
  input = index + previousHash + timestamp + data + nonce;
  hash = CryptoJS.SHA256(input)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;看到这里, 我们可以发现, 其实矿工的工作就是去猜&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce&lt;/code&gt;的值, 因为这个值很大, 所以计算难道也就比较大, 挖矿也就成了一件费时费力的事情。&lt;/p&gt;

&lt;p&gt;相应的, 既然挖矿是如此费时费力的一件事, 那么矿工也不会是义务劳动的, 矿工获得的相应收益, 会在下一部分 &lt;strong&gt;比特币&lt;/strong&gt; 中, 以比特币的运行规则来描述一下。&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html&quot;&gt;区块链入门教程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.freecodecamp.org/how-does-blockchain-really-work-i-built-an-app-to-show-you-6b70cd4caf7d&quot;&gt;How does blockchain really work? I built an app to show you&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@mvmurthy/ethereum-for-web-developers-890be23d1d0c&quot;&gt;Ethereum for web developers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="blog" /><category term="blockchain" /><summary type="html">最近了解了一些区块链的东西，动了一些深入了解的心思。</summary></entry><entry><title type="html">解决 firefox 不能使用 charles 的问题</title><link href="https://tobeyouth.github.io/pages/tobeyouth/blog/2018/03/21/charles_and_firefox/" rel="alternate" type="text/html" title="解决 firefox 不能使用 charles 的问题" /><published>2018-03-21T00:00:00+00:00</published><updated>2018-03-21T00:00:00+00:00</updated><id>https://tobeyouth.github.io/pages/tobeyouth/blog/2018/03/21/charles_and_firefox</id><content type="html" xml:base="https://tobeyouth.github.io/pages/tobeyouth/blog/2018/03/21/charles_and_firefox/">&lt;p&gt;基本不用 firefox，今天有同事报了个 firefox 上的问题，下了个 firefox。
想着用 charles 抓下包看下，结果发现并不能抓到任何包。感觉有点儿奇怪，试了一下其他的浏览器，safari 和 chrome 都可以，唯独
firefox 不行。&lt;/p&gt;

&lt;p&gt;于是 google 了一下，发现了一个 charles 官方推出的 firefox 插件 &lt;a href=&quot;https://addons.mozilla.org/zh-CN/firefox/addon/charles-proxy/&quot;&gt;charles-proxy&lt;/a&gt;，但很遗憾，新版本的 firefox 已经不能用了。&lt;/p&gt;

&lt;p&gt;在 firefox 的 preferences 里看了下 proxy 的设置，感觉可能是这里的问题，于是就尝试着改了一下 proxy 的设置，改成了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Menu
proxy configuration&lt;/code&gt;，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;'./firefox-proxy.png'&quot; alt=&quot;firefox proxy configuration&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt; 就是当前本机的地址，后面的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8888&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8889&lt;/code&gt;是我本机 charles 占用的端口号。&lt;/p&gt;

&lt;p&gt;配置完之后，发现还是不行，又想了一下，感觉可能是 https 的问题。于是又在 preferences 里搜了一下
certificates，发现果然可以设置，点击一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View Certificates&lt;/code&gt; :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;'./firefox-certificates.png'&quot; alt=&quot;view certificates&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到一堆证书的设置，还有个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Import&lt;/code&gt; 的按钮，打开本机的 keychain accesss，可以看到之前安装过的 charles
的证书，把这个证书导出来一份，然后再导入到 firefox 中就可以了。&lt;/p&gt;

&lt;p&gt;导入完证书，刷了一下网页，果然可以捕获到正确的请求了。&lt;/p&gt;

&lt;p&gt;解决了问题，想了一下原理。&lt;/p&gt;

&lt;p&gt;charles 本身应该是通过在本地起一个proxy server，然后把系统中的请求都转发到本地的 proxy server 来进行抓包的。firefox
之所以不行，可能是因为 firefox 默认绕过了系统中设置的 proxy，所以需要手动设置一下 proxy 才可以。&lt;/p&gt;</content><author><name></name></author><category term="blog" /><category term="charles" /><category term="firefox" /><category term="exp" /><summary type="html">基本不用 firefox，今天有同事报了个 firefox 上的问题，下了个 firefox。 想着用 charles 抓下包看下，结果发现并不能抓到任何包。感觉有点儿奇怪，试了一下其他的浏览器，safari 和 chrome 都可以，唯独 firefox 不行。</summary></entry><entry><title type="html">搭建 shadowsocks 记录</title><link href="https://tobeyouth.github.io/pages/tobeyouth/blog/2018/01/24/%E6%90%AD%E5%BB%BA-shadowsocks%E8%AE%B0%E5%BD%95/" rel="alternate" type="text/html" title="搭建 shadowsocks 记录" /><published>2018-01-24T00:00:00+00:00</published><updated>2018-01-24T00:00:00+00:00</updated><id>https://tobeyouth.github.io/pages/tobeyouth/blog/2018/01/24/%E6%90%AD%E5%BB%BA%20shadowsocks%E8%AE%B0%E5%BD%95</id><content type="html" xml:base="https://tobeyouth.github.io/pages/tobeyouth/blog/2018/01/24/%E6%90%AD%E5%BB%BA-shadowsocks%E8%AE%B0%E5%BD%95/">&lt;h3 id=&quot;前期准备&quot;&gt;前期准备&lt;/h3&gt;

&lt;p&gt;因为最近使用的第三方 vpn 快到期了，所以打算自己搭个 shadowsocks 用。
找了一些国外的 vps 提供方，最后发现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vultr&lt;/code&gt; 算是最实惠的，有个 &lt;strong&gt;2.5美金/月&lt;/strong&gt; ，相较于 linode 的 &lt;strong&gt;5美金/月&lt;/strong&gt;，虽然配置差了一些，但是简单作为梯子用，还是够用了。&lt;/p&gt;

&lt;p&gt;搭建的过程非常简单，首先就是注册 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vultr&lt;/code&gt;，然后充值，先充了个10美金，另外，vultr 比 linode 更方便的一点是不需要国际信用卡，可以直接用支付宝付款。&lt;/p&gt;

&lt;p&gt;付完款，可以直接挑选节点和主机配置等，离国内比较近的日本和新加坡节点都比较贵，为了追求便宜，所以随便选了个美国节点。&lt;/p&gt;

&lt;p&gt;选完节点和配置，接下来是选择系统，因为只用过 centos 和 ubuntu，又想省得折腾，所以直接选了 ubuntu。&lt;/p&gt;

&lt;h3 id=&quot;登录主机&quot;&gt;登录主机&lt;/h3&gt;

&lt;p&gt;新建完主机，用网站上提供的账号和 ip 先 ssh 到主机上&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh root@主机 ip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这时会要求输入密码，可以直接把网站上提供的主机密码 copy 过去。密码验证通过，会进入到主机的目录中。&lt;/p&gt;

&lt;p&gt;为了避免以后每次都要输入 ip 和密码，可以把主机 ip 先在本机上加个 host:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vi /private/etc/hosts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后用&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip 随便起个名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;的格式给 ip 起个方便好记的别名。&lt;/p&gt;

&lt;p&gt;接下来可以参考&lt;a href=&quot;https://tobeyouth.github.io/blog/2014/07/14/ssh-login/&quot;&gt;这篇&lt;/a&gt;在你的主机上添加个本机的 ssh-key，这样以后就不用输密码了。&lt;/p&gt;

&lt;h3 id=&quot;正式搭建-shadowsocks-server&quot;&gt;正式搭建 shadowsocks server&lt;/h3&gt;

&lt;p&gt;这里我使用了这个项目&lt;a href=&quot;https://github.com/teddysun/shadowsocks_install&quot;&gt;shadowsocks_install&lt;/a&gt;，直接一行命令搞定&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh
chmod +x shadowsocks-all.sh
./shadowsocks-all.sh 2&amp;gt;&amp;amp;1 | tee shadowsocks-all.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中会有个步骤需要选择用什么版本的 shadowsocks，我选择的是&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shadowsocks-libev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;看起来这个版本的 github 是比较活跃的，所以也推荐大家使用这个版本。&lt;/p&gt;

&lt;p&gt;之后就是需要输入密码和端口号了&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Please enter password for shadowsocks-libev
(default password: teddysun.com):

password = teddysun.com

Please enter a port for shadowsocks-libev [1-65535]
(default port: 8989):

port = 8989

Press any key to start...or Press Ctrl+C to cancel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;全部搞定后，你的 shadowsockss 就搭建成功了。&lt;/p&gt;

&lt;h3 id=&quot;客户端&quot;&gt;客户端&lt;/h3&gt;

&lt;p&gt;windows, mac, android, ios 上都有相应的开源客户端，可以自行下载安装&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/shadowsocks/shadowsocks-windows&quot;&gt;window&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/shadowsocks/ShadowsocksX-NG&quot;&gt;mac&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/shadowsocks/shadowsocks-android&quot;&gt;android&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/shadowsocks/shadowsocks-iOS&quot;&gt;ios&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为 ios 的相关客户端已经在 github 上被删除，所以建议使用其他客户端代替，我使用的是一个叫&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssrconnectPro&lt;/code&gt;的免费 app。
当然，使用收费的 app 效果可能会更好，例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;surge&lt;/code&gt; 什么的。&lt;/p&gt;

&lt;h3 id=&quot;使用客户端&quot;&gt;使用客户端&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先，要选择链接类型为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shadowsocks&lt;/code&gt; ，有的客户端中简称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ss&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;接下来填入你的主机的 ip 和前面设置好的端口号和密码。&lt;/li&gt;
  &lt;li&gt;保存、链接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;等成功链接之后，就可以正常访问 google 和 facebook 等并不存在的网站啦！&lt;/p&gt;

&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;
&lt;p&gt;一些相关资源和教程的地址&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://shadowsocks.be/&quot;&gt;shadowsocks.be&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/shadowsocks&quot;&gt;shadowsocks in github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.diycode.cc/topics/738&quot;&gt;轻松在 VPS 搭建 Shadowsocks 翻墙&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="blog" /><category term="exp" /><category term="shadowsockss" /><category term="vultr" /><summary type="html">前期准备</summary></entry><entry><title type="html">调试移动网页的几种方法</title><link href="https://tobeyouth.github.io/pages/tobeyouth/blog/2018/01/24/some-way-to-debug-mobile-web-pages/" rel="alternate" type="text/html" title="调试移动网页的几种方法" /><published>2018-01-24T00:00:00+00:00</published><updated>2018-01-24T00:00:00+00:00</updated><id>https://tobeyouth.github.io/pages/tobeyouth/blog/2018/01/24/some-way-to-debug-mobile-web-pages</id><content type="html" xml:base="https://tobeyouth.github.io/pages/tobeyouth/blog/2018/01/24/some-way-to-debug-mobile-web-pages/">&lt;p&gt;在调试移动网页时，通常开发时会直接使用 chrome 来模拟移动设备。&lt;/p&gt;

&lt;p&gt;但毕竟跟真实环境还是有差别，很多问题还是需要到真实设备上才能发现。&lt;/p&gt;

&lt;p&gt;以下会列举几种我在开发过程中用到过的几种调试方式，就当做个总结吧。&lt;/p&gt;

&lt;h3 id=&quot;safari&quot;&gt;Safari&lt;/h3&gt;

&lt;p&gt;首先是最简单的调试方法，通常在调试 ios 网页上的问题时，最常用的就是用手机连接到电脑，打开 safari ，就可以调试手机上 safari 所打开的网页了。&lt;/p&gt;

&lt;p&gt;具体的路径是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;safari -&amp;gt; develop -&amp;gt; xxx 的iphone -&amp;gt; 打开的网页
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;点击之后会出现 safari 的控制台，可以在这里查看网络请求、console 输出、dom 结构、样式和打断点等。&lt;/p&gt;

&lt;p&gt;使用 safari 比较常见的问题就是，在 menu bar 上会找不到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;develop&lt;/code&gt;这个 menu。如果看不到这个 menu 的话，需要在&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;safari -&amp;gt; preferences -&amp;gt; Advanced
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个弹出框的最下面有一行&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Show Develop menu in menu bar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;把这个勾选上就可以了。&lt;/p&gt;

&lt;h3 id=&quot;charles&quot;&gt;Charles&lt;/h3&gt;

&lt;p&gt;通常情况下，Safari 可以解决大部分调试问题，但是一些网络请求相关的问题，还是用 Charles 会比较方便。&lt;/p&gt;

&lt;p&gt;这里简单的说一下怎么在 mac 上使用 Charles 查看移动设备上的网络请求。&lt;/p&gt;

&lt;h4 id=&quot;安装-charles&quot;&gt;安装 Charles&lt;/h4&gt;

&lt;p&gt;要使用 Charles，首先你要有个 Charles。&lt;/p&gt;

&lt;p&gt;可以去官网下载试用版，有钱的话，建议直接买个 license 用正式版，毕竟花钱买个舒心。&lt;/p&gt;

&lt;p&gt;如果舍不得花这个钱，去网上搜一搜各种破解版本也是有的。&lt;/p&gt;

&lt;h4 id=&quot;配置-http-代理&quot;&gt;配置 http 代理&lt;/h4&gt;

&lt;p&gt;按照这个路径&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Proxy -&amp;gt; Proxy Setting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;打开 Proxy Setting 的弹窗&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./charles-proxy-setting.jpg&quot; alt=&quot;就是这个弹窗&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;配置 Port 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8888&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;勾选 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Enable transparent HTTP proxying&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;勾选 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SOCKS Proxy&lt;/code&gt;，把下面的 Port 设置成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8889&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;勾选 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Enable HTTP proxying over SOCKS&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;勾选 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Include default HTTP ports&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;点击 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OK&lt;/code&gt; 保存配置&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;配置-ssl-代理&quot;&gt;配置 ssl 代理&lt;/h4&gt;

&lt;p&gt;按照这个路径&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Proxy -&amp;gt; SSL Proxying Setting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;打开 SSL Proxying 的弹窗&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./charles-proxy-setting-ssl.jpg&quot; alt=&quot;就是这个弹窗&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;点击&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Add&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Host&lt;/code&gt;填 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Port&lt;/code&gt;填&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;443&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;点击&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OK&lt;/code&gt; 保存端口设置&lt;/li&gt;
  &lt;li&gt;再点击&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OK&lt;/code&gt;保存 SSL 设置&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;在本地安装-ssl-证书&quot;&gt;在本地安装 ssl 证书&lt;/h4&gt;

&lt;p&gt;按照这个路径&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Help -&amp;gt; SSL Proxying -&amp;gt; Install Charles Root Certificate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;./charles-proxy-install.png&quot; alt=&quot;就是这里&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在本地安装信任证书，并选择&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Trust&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;在移动设备配置信任证书&quot;&gt;在移动设备配置信任证书&lt;/h4&gt;

&lt;p&gt;按照这个路径&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Help -&amp;gt; SSL Proxying -&amp;gt; Install Charles Root Certificate on a Mobile Device for Remote Browser
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;./charles-proxy-install-remote.png&quot; alt=&quot;就是这里&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击之后会弹出个对话框：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./charles-proxy-install-remote-client.jpg&quot; alt=&quot;就是这里&quot; /&gt;&lt;/p&gt;

&lt;p&gt;把这里的地址输入到手机的浏览器中，就会自动下载/安装一个信任证书到手机中。在一些版本的 iOS 设备中，还需要到&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;设置 -&amp;gt; 通用 -&amp;gt; 描述文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;中点击一下&lt;strong&gt;信任&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;在移动设备中配置代理&quot;&gt;在移动设备中配置代理&lt;/h4&gt;

&lt;p&gt;按照这个路径&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;设置 -&amp;gt; Wifi(点击网络名称右侧的感叹号) -&amp;gt; Http 代理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;来到这个界面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./charles-mobile-http-setting.jpg&quot; alt=&quot;就是这里&quot; /&gt;&lt;/p&gt;

&lt;p&gt;把代理的 ip 地址和端口号填进去就可以了。&lt;/p&gt;

&lt;p&gt;ip 地址就是使用 Charles 的主机在当前网络中的 ip 地址，如果不清楚的话，可以在 Charles 中按照以下的路径查看&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Help -&amp;gt; Local Address
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;./charles-help-ip.png&quot; alt=&quot;就是这里&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击之后会出现一个弹窗&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./charles-help-ip-modal.png&quot; alt=&quot;就是这里&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;en0&lt;/code&gt;表示的就是本机在网络中的地址，也就是要在移动设备中填入的 ip 地址。&lt;/p&gt;

&lt;p&gt;端口号填&lt;a href=&quot;#&quot;&gt;配置 http 代理&lt;/a&gt;这里配置的端口号就可以了。&lt;/p&gt;

&lt;p&gt;完成以上的配置，就可以在 Charles 中查看到移动设备中的网络请求了。&lt;/p&gt;

&lt;h3 id=&quot;ios-webkit-debug-proxy&quot;&gt;iOS WebKit Debug Proxy&lt;/h3&gt;

&lt;p&gt;除了 Charles 外，最近又发现了一款类似的代理工具，并且是开源的，项目地址可见&lt;a href=&quot;https://github.com/google/ios-webkit-debug-proxy&quot;&gt;ios-webkit-debug-proxy&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;具体的原理跟 Charles 类似，配置方法相对来说要比 Charles 简单一些，直接按照项目文档中的描述一步步来就可以了，这里就不再描述了。&lt;/p&gt;

&lt;p&gt;相较于 Charles ，这个工具更先进的一点是可以指定 chrome devtools 作为调试工具，但是需要额外安装另一个工具&lt;a href=&quot;https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter&quot;&gt;remotedebug-ios-webkit-adapter&lt;/a&gt;。&lt;/p&gt;</content><author><name></name></author><category term="blog" /><category term="debug" /><category term="mobile" /><summary type="html">在调试移动网页时，通常开发时会直接使用 chrome 来模拟移动设备。</summary></entry><entry><title type="html">开发了一个小网站</title><link href="https://tobeyouth.github.io/pages/tobeyouth/blog/2017/12/22/brackish-develop/" rel="alternate" type="text/html" title="开发了一个小网站" /><published>2017-12-22T00:00:00+00:00</published><updated>2017-12-22T00:00:00+00:00</updated><id>https://tobeyouth.github.io/pages/tobeyouth/blog/2017/12/22/brackish-develop</id><content type="html" xml:base="https://tobeyouth.github.io/pages/tobeyouth/blog/2017/12/22/brackish-develop/">&lt;p&gt;最近空余时间一直在开发一个小网站，用到了以下的一些技术栈&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;docker&lt;/li&gt;
  &lt;li&gt;python&lt;/li&gt;
  &lt;li&gt;flask&lt;/li&gt;
  &lt;li&gt;mysql&lt;/li&gt;
  &lt;li&gt;supervisor&lt;/li&gt;
  &lt;li&gt;nginx&lt;/li&gt;
  &lt;li&gt;scary&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在开发的过程中碰到了不少大大小小的坑，这里权当个记录，如果以后再碰到这样的坑，可以快速的跳出来。&lt;/p&gt;

&lt;h3 id=&quot;项目的结构&quot;&gt;项目的结构&lt;/h3&gt;

&lt;p&gt;首先来说一下项目的结构，初衷是想抓点儿美女图片做个图片站。说到抓数据，首先想到的就是 python 的爬虫框架
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scary&lt;/code&gt;，事实上也确实使用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scary&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;数据抓回来后，还需要有个网站去展示，所以还需要做个简单的小网站。因为工作中也写一点儿 Python，并且不太喜欢写
nodejs，所以自然而然网站就选择了用 Python 进行开发。&lt;/p&gt;

&lt;p&gt;web 框架方面选择了 Flask，原因就是相比 Django
来说比较简单，虽然功能也比较薄弱吧，但是一个小破网站也不需要太多的功能，只要能快速的搭建起来就好了。&lt;/p&gt;

&lt;p&gt;所以整个项目被分成了两个部分&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;爬虫&lt;/li&gt;
  &lt;li&gt;展示&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为考虑到爬虫只能算是一个简单功能，所以将爬虫做了单独的部署，也方便之后下线。&lt;/p&gt;

&lt;h3 id=&quot;docker&quot;&gt;docker&lt;/h3&gt;

&lt;p&gt;说到开发，在开发 Python 项目时，比较传统的是使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;virtualenv&lt;/code&gt;，也就是给通过改变环境变量的方式给 Python
虚拟出一个运行环境来。但是考虑到日后如果想要迁移到云服务器上的话，还需要自己手动去安装 mysql 等一系列的依赖，不如直接用
docker 来个一步到到位的部署。&lt;/p&gt;

&lt;p&gt;所以还是决定用 docker 来做本地的开发和之后的部署。&lt;/p&gt;

&lt;p&gt;第一次接触 docker，也没怎么看文档，直接上手就开始搞，网上的 docker 教程一抓一大把，看了几个之后慢慢的有了一点儿理解。&lt;/p&gt;

&lt;p&gt;在Docker 的世界里有 image 和 container 两个概念。&lt;/p&gt;

&lt;p&gt;image 就相当于一个手册，Docker 将通过不同的 image 来构建不同的 Container。或者换一个角度，也可以把 image
理解成面向对象中的 class, container 就是通过这个 image 生成出来的实例。&lt;/p&gt;

&lt;p&gt;通过不同的 image 我们构建不同的 container，我们可以依赖他人的 image 来生成自己的 image，再通过自己的 image 来生成自己的
container，最终我们的应用就跑在我们生成出来的这个 container 中。&lt;/p&gt;

&lt;p&gt;对于我这种只想简单开发和部署的人来说，docker像是一个配置白皮书，只要写好 Dockerfile，就可以方便的将本地开发的环境迁移到任何机器上，安装依赖执行初始化脚本，都可以一键执行完。&lt;/p&gt;

&lt;p&gt;既然是一键执行，那一定事先有个配置文件，这个配置文件就是 Dockerfile。
Dockerfile 的作用就是生成 image, 然后就可以根据这个 image 来生成 container，运行应用了。&lt;/p&gt;

&lt;p&gt;这里简单的把我的 Dockerfile 列出来，可以对照着这个 Dockerfile 写一份自己的 Dockerfile&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM ubuntu
MAINTAINER tobeyouth &amp;lt;tobeyouth@gmail.com&amp;gt;


# copy from p0bailey/docker-flask
ENV DEBIAN_FRONTEND noninteractive

RUN apt-get update

RUN apt-get install -y uwsgi
RUN apt-get install -y python-pip 
RUN apt-get install -y python
RUN apt-get install -y uwsgi-plugin-python
RUN apt-get install -y nginx 
RUN apt-get install -y supervisor
RUN apt-get install -y mysql-server
RUN apt-get install -y curl
RUN apt-get install -y vim

COPY nginx/flask.conf /etc/nginx/sites-available/
COPY supervisor/supervisord.conf /etc/supervisor/conf.d/supervisord.conf
COPY app /var/www/app

# install deps
ADD requirements.txt /tmp/requirements.txt
RUN pip install -r /tmp/requirements.txt

RUN mkdir -p /var/log/nginx/app /var/log/uwsgi/app /var/log/supervisor \
    &amp;amp;&amp;amp; rm /etc/nginx/sites-enabled/default \
    &amp;amp;&amp;amp; ln -s /etc/nginx/sites-available/flask.conf /etc/nginx/sites-enabled/flask.conf \
    &amp;amp;&amp;amp; echo &quot;daemon off;&quot; &amp;gt;&amp;gt; /etc/nginx/nginx.conf \
    &amp;amp;&amp;amp; chown -R www-data:www-data /var/www/app \
    &amp;amp;&amp;amp; chown -R www-data:www-data /var/log \
    &amp;amp;&amp;amp; RUN mkdir /var/run/mysqld \
    &amp;amp;&amp;amp; chown -R mysql:mysql /var/run/mysqld


# node env
RUN apt-get install -y nodejs

CMD [&quot;/usr/bin/supervisord&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FROM&lt;/code&gt; 这句，这表示我的运行环境将依赖于一个名字叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubuntn&lt;/code&gt; 的 image, 在这个 image 构建的 container
基础上，会继续添加我自己的一些设置，已完成我对应用运行环境的需求。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAINTAINER&lt;/code&gt;就表示了这个 Dockerfile 的作者信息，出了事故可以找作者背锅。&lt;/p&gt;

&lt;p&gt;接下来的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENV&lt;/code&gt; 就是设计个环境变量, 设置这个环境变量是什么意思，其实我也不知道，去 github
上看了一下，貌似这个是个默认设置，那就这样吧。&lt;/p&gt;

&lt;p&gt;在接下来主要就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUN&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COPY&lt;/code&gt; 这些命令，跟名字一样，就是执行一些命令和 copy 一些文件到 container 中。&lt;/p&gt;

&lt;p&gt;最后是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMD&lt;/code&gt;，这个就是执行初始化的命令，比如我这里执行的就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;supervisord&lt;/code&gt;，至于什么是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;supervisord&lt;/code&gt;，接下来会再说一下。&lt;/p&gt;

&lt;p&gt;写好自己的 Dockerfile 后，需要执行一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker build {image_name}:{image_tag} {image_path}&lt;/code&gt; 来生成自己的
image，经过漫长的 build 过程之后，如果不出什么错误，就可以执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt; 来创建自己的 container 了。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt;
有很多参数，具体可以看&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/run/#options&quot;&gt;这里&lt;/a&gt;，当然也可以写个简单的小脚本来执行，比如我的这个&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#!/bin/bash

IMAGE_NAME='brackish'
CWD=`pwd`
CONTAINER_PORT=80
VIEW_PORT=80

docker run -i -t -d -v ${CWD}/app:/var/www/app -p ${CONTAINER_PORT}:${VIEW_PORT} ${IMAGE_NAME}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt; 加了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-d&lt;/code&gt; 参数，执行之后会输出一个 container_id，这个就是所创建的 container 的 id 了，之后还需要通过这个 id
删除或者访问 container 。不过不小心忘了也没事儿，还可以通过&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker container ls -a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;来查看所有的 container。&lt;/p&gt;</content><author><name></name></author><category term="blog" /><category term="python" /><category term="mysql" /><category term="docker" /><category term="flask" /><category term="supervisor" /><summary type="html">最近空余时间一直在开发一个小网站，用到了以下的一些技术栈</summary></entry><entry><title type="html">一个有意思的问题</title><link href="https://tobeyouth.github.io/pages/tobeyouth/2017/11/29/%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E9%97%AE%E9%A2%98/" rel="alternate" type="text/html" title="一个有意思的问题" /><published>2017-11-29T00:00:00+00:00</published><updated>2017-11-29T00:00:00+00:00</updated><id>https://tobeyouth.github.io/pages/tobeyouth/2017/11/29/%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E9%97%AE%E9%A2%98</id><content type="html" xml:base="https://tobeyouth.github.io/pages/tobeyouth/2017/11/29/%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E9%97%AE%E9%A2%98/">&lt;p&gt;最近在开发一个简单的 webide 时，发现了一个诡异的问题。&lt;/p&gt;

&lt;p&gt;使用 fetch 更新数据，如果 header 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;content-type&lt;/code&gt; 设置成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/x-www-form-urlencoded;&lt;/code&gt;, 发送类似 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{srouce:
&quot;1+2+3&quot;}&lt;/code&gt; 这样的数据，会被替换成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{source: &quot;1 2 3&quot;}&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;号都被替换成了空格，后来又试了一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;。发现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;
也会被替换。&lt;/p&gt;

&lt;p&gt;但是把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;content-type&lt;/code&gt; 改成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/json;&lt;/code&gt; 就不会存在这个问题了。&lt;/p&gt;

&lt;p&gt;抱着求证的态度跟同事讨论了一下，发现了这样的一个&lt;a href=&quot;https://www.w3.org/TR/html401/interact/forms.html#form-content-type&quot;&gt;描述&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This is the default content type. Forms submitted with this content type must be encoded as follows:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;Control names and values are escaped. Space characters are replaced by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+', and then reserved characters are escaped as described in [RFC1738], section 2.2: Non-alphanumeric characters are replaced by &lt;/code&gt;%HH’, a percent sign and two hexadecimal digits representing the ASCII code of the character. Line breaks are represented as “CR LF” pairs (i.e., `%0D%0A’).&lt;/li&gt;
    &lt;li&gt;The control names/values are listed in the order they appear in the document. The name is separated from the value by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=' and name/value pairs are separated from each other by &lt;/code&gt;&amp;amp;’.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;看起来是和 url 的 encoding 有关，点进文档中的链接又继续看了一下，发现了如下的描述：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.2. URL Character Encoding Issues&lt;/p&gt;

  &lt;p&gt;URLs are sequences of characters, i.e., letters, digits, and special
   characters. A URLs may be represented in a variety of ways: e.g., ink
   on paper, or a sequence of octets in a coded character set. The
   interpretation of a URL depends only on the identity of the
   characters used.
In most URL schemes, the sequences of characters in different parts
   of a URL are used to represent sequences of octets used in Internet
   protocols. For example, in the ftp scheme, the host name, directory
   name and file names are such sequences of octets, represented by
   parts of the URL.  Within those parts, an octet may be represented by&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大概想了一下，应该是因为空格在请求中会被替换成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;，所以如果数据中有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;的话，会被当成空格，所以就直接被转成了空格。&lt;/p&gt;

&lt;p&gt;针对这个问题，如果不想更改 header 的话，使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;encodeURIComponent&lt;/code&gt; 把字符串 encode 一下也是可以的。&lt;/p&gt;</content><author><name></name></author><summary type="html">最近在开发一个简单的 webide 时，发现了一个诡异的问题。</summary></entry><entry><title type="html">redux-saga</title><link href="https://tobeyouth.github.io/pages/tobeyouth/blog/2017/08/23/redux-saga/" rel="alternate" type="text/html" title="redux-saga" /><published>2017-08-23T00:00:00+00:00</published><updated>2017-08-23T00:00:00+00:00</updated><id>https://tobeyouth.github.io/pages/tobeyouth/blog/2017/08/23/redux-saga</id><content type="html" xml:base="https://tobeyouth.github.io/pages/tobeyouth/blog/2017/08/23/redux-saga/">&lt;p&gt;最近组里的同事在尝试使用 &lt;a href=&quot;https://redux-saga.js.org&quot;&gt;redux-saga&lt;/a&gt; 改造一些异步请求比较多的功能。
对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 早有耳闻，但是出于懒，一直没去关注，这次就着帮同事做 code review 看了一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt;
的文档和代码，以下是学习过程中的一些心得和体会。&lt;/p&gt;

&lt;p&gt;按照以往学习的思路，一个被众人推崇的东西，一定有这几方面是值得学习和思考的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设计哲学&lt;/li&gt;
  &lt;li&gt;解决的问题&lt;/li&gt;
  &lt;li&gt;使用后的效果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下的体会也将从这三个方面来总结一下&lt;/p&gt;

&lt;h3 id=&quot;设计哲学&quot;&gt;设计哲学&lt;/h3&gt;

&lt;p&gt;在使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 之前，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 中处理异步请求，通常是使用 &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;
来解决的。&lt;/p&gt;

&lt;p&gt;这里多扯一些关于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-thunk&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 之间的关系和差异&lt;/p&gt;

&lt;h4 id=&quot;redux&quot;&gt;redux&lt;/h4&gt;
&lt;p&gt;先来说 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 本身是一个完整的控制数据流的框架。在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 中我们通常关心的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducer&lt;/code&gt; ,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middleware&lt;/code&gt;以及
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;provider&lt;/code&gt; 中的元素如何响应数据的变化。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 精简了整个流程，使 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducer&lt;/code&gt; 都只需要 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt;
即可，这样每个部分看起来都可以当做是纯函数，相应的，测试起来也很方便，毕竟是纯函数，固定的输入对应固定的输出。&lt;/p&gt;

&lt;h4 id=&quot;redux-thunk&quot;&gt;redux-thunk&lt;/h4&gt;
&lt;p&gt;但是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 本身的简单，单纯的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; 并不能处理异步需求。所以才会使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-thunk&lt;/code&gt; 这样的插件。&lt;/p&gt;

&lt;p&gt;但是需要注意的是，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-thunk&lt;/code&gt; 并不是只为了完成异步需求才会被创造出来的。要理解&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;react-thunk&lt;/code&gt;，首先要了解一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thunk&lt;/code&gt;
这个概念&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A thunk is a function that wraps an expression to delay its evaluation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说白了的话，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thunk&lt;/code&gt; 是一个被延迟执行的函数。&lt;/p&gt;

&lt;p&gt;那么&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-thunk&lt;/code&gt;是怎么解决异步的问题呢？可以直接看下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-thunk&lt;/code&gt; 的源码，非常非常非常短&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) =&amp;gt; next =&amp;gt; action =&amp;gt; {
    if (typeof action === 'function') {
      return action(dispatch, getState, extraArgument);
    }

    return next(action);
  };
}

const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

export default thunk;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之所以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-thunk&lt;/code&gt; 可以解决异步的问题，是因为将异步的部分包装成了一个 function，并传入了
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store.dispatch&lt;/code&gt;，这样可以在异步完成之后再调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 触发 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducer&lt;/code&gt; 的中的响应。&lt;/p&gt;

&lt;p&gt;所以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-thunk&lt;/code&gt; 的本质是将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 中返回的函数执行。&lt;/p&gt;

&lt;h4 id=&quot;redux-saga&quot;&gt;redux-saga&lt;/h4&gt;

&lt;p&gt;相比于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-thunk&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 更像是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middlewaras&lt;/code&gt;之外，通过监听 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 提供了一个执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task&lt;/code&gt;
的地方。&lt;/p&gt;

&lt;p&gt;另外，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 比较突出的特点是使用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generator&lt;/code&gt; 特性，使异步的返回可以用更流畅的语法来表示。&lt;/p&gt;

&lt;h3 id=&quot;解决的问题&quot;&gt;解决的问题&lt;/h3&gt;

&lt;p&gt;在一个多交互的页面中，通常会有多个动作触发同一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 的时候。比如在购物车中，&lt;strong&gt;加/减数量&lt;/strong&gt;, &lt;strong&gt;选择/取消选择商品&lt;/strong&gt;,
&lt;strong&gt;删除商品&lt;/strong&gt;都会触发重新计算总价的请求。使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-thunk&lt;/code&gt; 的做法是写一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middleware&lt;/code&gt; ，监听所有经过的
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt;，如果发现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 是会触发计算总价的请求中的几种，就会去计算总价，等回调完成后再更新总价。&lt;/p&gt;

&lt;p&gt;这个时候就容易出现多个计算请求的情况，因为是异步请求，所以其返回顺序不一定，所以更新总价时会造成错误。&lt;/p&gt;

&lt;p&gt;如果用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;radux-saga&lt;/code&gt; 来解决这个问题的话，可以使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;takeLastest&lt;/code&gt; 来执行最后一次被触发的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task&lt;/code&gt;，之前被触发的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task&lt;/code&gt;
都会被取消，从而也就解决了这个问题。&lt;/p&gt;

&lt;p&gt;当然，这只是一个简单的例子；其实通过其他方法也可以实现在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-thunk&lt;/code&gt; 中实现取消未完成的异步请求的功能。&lt;/p&gt;

&lt;h3 id=&quot;使用后的效果&quot;&gt;使用后的效果&lt;/h3&gt;

&lt;p&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 的效果可以从以下几个方法来看：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;写法上抛弃了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middlewares&lt;/code&gt; 的概念，因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt;本身就是一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middleware&lt;/code&gt;，这个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middleware&lt;/code&gt; 监听了
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt;，从而可以根据不同的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 处理 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux&lt;/code&gt; 中的副作用问题。可以简单的理解为将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middleware&lt;/code&gt; 全都迁移到了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sagas&lt;/code&gt;
目录中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 中的方法可以变得更&lt;strong&gt;纯粹&lt;/strong&gt;，不需要再在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 中处理异步问题，每一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt;
只是单纯的返回对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type&lt;/code&gt; 和相关数据即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 变得&lt;strong&gt;纯粹&lt;/strong&gt;，所以为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 编写测试也就更加方便&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;异步从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt;中专业到了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;saga&lt;/code&gt; 中，相应单元测试的编写也就从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 转移到了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;saga&lt;/code&gt;。但比较方便的是，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt;
 使用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generator&lt;/code&gt; ，在编写测试用例时，可以基本有同步写法的感觉。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;一些方法和概念&quot;&gt;一些方法和概念&lt;/h3&gt;

&lt;p&gt;简单的说完了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 的一些简介，这里着重列举一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 中的方法和概念。&lt;/p&gt;

&lt;h4 id=&quot;effects&quot;&gt;Effects&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effect&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 中的一个简单的对象定义&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effects&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 中对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt; 返回对象的包装。因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 中每一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;saga&lt;/code&gt; 都是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generator&lt;/code&gt; 函数，所以
每个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;返回都可以称作是一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effect&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 官方推荐使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga/effects&lt;/code&gt; 中的方法来创建一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effect&lt;/code&gt;
对象用于返回。但并不是一定要使用其中的方法才能创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effect&lt;/code&gt;，正如上面所说，每一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt; 返回都可以称之为一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effect&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;promise-call-apply&quot;&gt;promise, call, apply&lt;/h5&gt;

&lt;p&gt;最简单的方式是直接 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt; 一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Promise&lt;/code&gt; 对象，也可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply&lt;/code&gt; 等方式创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effect&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;但单纯的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt; 一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Promise&lt;/code&gt; 对象和通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga/effects&lt;/code&gt; 返回一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effect&lt;/code&gt; 对象是不同的。使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga/effects&lt;/code&gt; 提供的方法返回的，将是一个&lt;strong&gt;纯粹&lt;/strong&gt;的 javascript 对象，用于描述将要执行的操作，而这个操作，将不会立即执行，而是会到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 这个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middleware&lt;/code&gt; 中再去执行。&lt;/p&gt;

&lt;p&gt;下面我们通过两个例子来说明这两种方式的异同：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// yield a promise

function *getData(url) {
  const data = yield Api.Fetch(url)
  // ...
} 


// yield a effect
import { call } from 'redux-saga/effects'

function *getData(url) {
  const data = yield call(Api.Fetch, url)
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在针对返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;promise&lt;/code&gt; 对象的这个方法写测试时，我们可以这样写：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// unit test for yield promise

const iterator = getData(url)
assert.deepEqual(iterator.next().value, another_promise) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt; 返回的是个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;promise&lt;/code&gt; 对象，所以在这里我们如果想要测试，也只能创造另一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;promise&lt;/code&gt; 对象。
但我们这个单元测试的真正目的是为了测试&lt;strong&gt;调用 getData 这个方法，yield 后的方法会不会被正确的执行&lt;/strong&gt;，这样创造出另一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;promise&lt;/code&gt;
对象方法难免有些过于&lt;strong&gt;沉重&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;再来看下，使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call&lt;/code&gt; 方法返回了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effect&lt;/code&gt; 对象将要怎么测试:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// unit text for yield effect

const iterator = getData(url)
assert.deepEqual(iterator.next().value, call(Api.Fetch, url))

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们只需要再调用一次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Api.Fetch&lt;/code&gt; 方法，并不需要关心&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call&lt;/code&gt; 调用的是什么方法，写起测试来，感觉可以更&lt;strong&gt;无脑&lt;/strong&gt;一些。&lt;/p&gt;

&lt;h5 id=&quot;dispatch-put&quot;&gt;dispatch, put&lt;/h5&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;saga&lt;/code&gt; 的实际编写中，经常会遇到某个异步请求结束后，需要 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 一个新的事件，以让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reducer&lt;/code&gt; 做出相应
。如果直接通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispath&lt;/code&gt; 方法传递事件和数据的话，单元测试将会无法覆盖到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispath&lt;/code&gt; 的动作。&lt;/p&gt;

&lt;p&gt;所以，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 提供了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put&lt;/code&gt; 方法，这个方法类似 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call&lt;/code&gt;，将会创建一个标准的可描述对象，将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 的操作放在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middleware&lt;/code&gt; 中执行。在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;saga&lt;/code&gt;方法中可以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;
这个对象，则可以在单元测试中覆盖这个操作。&lt;/p&gt;

&lt;h5 id=&quot;takeevery-takelast-take&quot;&gt;takeEvery, takeLast, take&lt;/h5&gt;

&lt;p&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;takeEvery&lt;/code&gt;，可以监听每一次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 的调用，并返回相应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effect&lt;/code&gt;并执行；与之不同的是
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;takeLast&lt;/code&gt;，将只执行最新的一次&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action&lt;/code&gt; 的调用。&lt;/p&gt;

&lt;p&gt;所以，使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;takeLast&lt;/code&gt; 可以准确的获取多次异步请求中最新的一次，解决上面所说的购物车问题。&lt;/p&gt;</content><author><name></name></author><category term="blog" /><category term="redux" /><category term="redux-saga" /><category term="javascript" /><summary type="html">最近组里的同事在尝试使用 redux-saga 改造一些异步请求比较多的功能。 对 redux-saga 早有耳闻，但是出于懒，一直没去关注，这次就着帮同事做 code review 看了一下 redux-saga 的文档和代码，以下是学习过程中的一些心得和体会。</summary></entry></feed>